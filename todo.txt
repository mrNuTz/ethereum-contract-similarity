DONE:
  CALLDATALOAD, CALLVALUE; CALLSIZE seams to be rare
  is swarm code removed from the skeletons? -> yes
  split framework and runs
  how can is split the framework and the test-runs and document the runs?
  extract abi jump table form contracts
  events? -> log
  define a few test sets
  select only code with distinct skeletons from es verified contracts and group by name + signatures
  verify that function are ordered by signatures in runtime code (deployed code) -> yes
  invalid byte-codes at the end of skeleton?
    Auxdata is the cryptographic fingerprint of the source code, used for verification.
    This is just data, and never executed by the EVM.
  add signature sim to many-solc-versions
  many-solc-versions
    why is there almost no signature overlap?
  ssdeep with spliced out 0s could perform pretty good, because functions are ordered
  add 2 more contract to many solc versions
  solc-versions optimization
  for each bytecode
    variance between groups / variance within groups
FIRST:
  tabulate txt file util -> just use a DataFrame
  similarity measures
    more byte filters
    different lzjd parameters
    ppdeep variations
      function splitting
    bzHash
TODO:
LATER:
  write a hello world smart contract and compile it
QUESTIONS:
  what are data sections?
  why are there multiple meta sections?
  how will this be used?
  how to split internal functions?
  deployment code vs deployed code?
  are internal functions ordered? how stable is the ordering?
  are external functions always ordered by signature?
  skeletize rstrip trailing zeros?
MAYBE:
  byteBags should be tuples
  solc versions
    abi encoding
    more contracts
NOTES:
  significant
    log
    Storage
    # Environmental Information
    # Block Information
    # System Operations

  select encode(addr, 'hex') from account where id = 485783246;
  bindata(cdeployed) as hex

  * Umwandlung von Header(s) in Signature(s)
    func2sig(text) ==> bytea
    func2sig(text[]) ==> bytea[]
    Beispiel: select func2sig('transfer(address,uint256)'); -- \xa9059cbb
  * Umwandlung von Header(s) in Id(s)
    func2sig(text) ==> integer
    func2sig(text[]) ==> integer[]
    Beispiel: select func2id('transfer(address,uint256)'); -- -1459249989
  * Umwandlung von Signature(s) in Header(s)
    func2sig(bytea) ==> text
    func2sig(bytea[]) ==> text[]
  * Umwandlung von Id(s) in Header(s)
    func2sig(integer) ==> text
    func2sig(integer[]) ==> text[]
  * Anzeige von Signaturen als Signatur+Header
    display_funsig(bytea) ==> text
    display_funsig(id) ==> text
    display_funsig(bytea[]) ==> text
    display_funsig(id[]) ==> text
    Beispiel: select display_funcsig(-1459249989); -- 'a9059cbb transfer(address,uint256)'
  * Umwandlung zwischen Signature(s) und Integer-Id(s)
    sig2id(bytea) ==> integer
    sig2id(bytea[]) ==> integer[]
    id2sig(integer) ==> bytea
    id2sig(integer[]) ==> bytea[]


