DONE:
  CALLDATALOAD, CALLVALUE; CALLSIZE seams to be rare
  is swarm code removed from the skeletons? -> yes
  split framework and runs
  how can is split the framework and the test-runs and document the runs?
  extract abi jump table form contracts
  events? -> log
  define a few test sets
  verify that function are ordered by signatures in runtime code (deployed code) -> yes
FIRST:
  add signature sim to many-solc-versions

  many-solc-versions
    why is there almost no signature overlap?
TODO:
  solc versions:
    add abi version and optimization

  op-code filters
  lzjd arguments
  bzHash
  ssdeep with function splitting
  ssdeep with spliced out 0s could perform pretty good, because functions are ordered
LATER:
  write a hello world smart contract and compile it
QUESTIONS
  how will this be used?
  how to split internal functions?
  deployment code vs deployed code?
  are internal functions ordered? how stable is the ordering?
  are external functions always ordered by signature?
  invalid byte-codes at the end of skeleton?
  skeletize rstrip trailing zeros?
NOTES:
  significant
    log
    Storage
    # Environmental Information
    # Block Information
    # System Operations

  Auxdata is the cryptographic fingerprint of the source code, used for verification.
  This is just data, and never executed by the EVM.

  select encode(addr, 'hex') from account where id = 485783246;
  bindata(cdeployed) as hex
  select only code with distinct skeletons from es verified contracts and group by name + signatures

  * Umwandlung von Header(s) in Signature(s)
    func2sig(text) ==> bytea
    func2sig(text[]) ==> bytea[]
    Beispiel: select func2sig('transfer(address,uint256)'); -- \xa9059cbb
  * Umwandlung von Header(s) in Id(s)
    func2sig(text) ==> integer
    func2sig(text[]) ==> integer[]
    Beispiel: select func2id('transfer(address,uint256)'); -- -1459249989
  * Umwandlung von Signature(s) in Header(s)
    func2sig(bytea) ==> text
    func2sig(bytea[]) ==> text[]
  * Umwandlung von Id(s) in Header(s)
    func2sig(integer) ==> text
    func2sig(integer[]) ==> text[]
  * Anzeige von Signaturen als Signatur+Header
    display_funsig(bytea) ==> text
    display_funsig(id) ==> text
    display_funsig(bytea[]) ==> text
    display_funsig(id[]) ==> text
    Beispiel: select display_funcsig(-1459249989); -- 'a9059cbb transfer(address,uint256)'
  * Umwandlung zwischen Signature(s) und Integer-Id(s)
    sig2id(bytea) ==> integer
    sig2id(bytea[]) ==> integer[]
    id2sig(integer) ==> bytea
    id2sig(integer[]) ==> bytea[]
THOUGHTS:
  lzjd correlations much better to signature-similarity than ssdeep and its really fast
  ssdeep can't event beat counting bytes of the skeleton

  ssdeep with jaccard underperforms levenshtein because of the high number of 'K' chunk hashes.

  signatures in the jump table at the beginning of the contract are sorted
    and the functions jumped to are sorted as well

  UniswapV2Router02 changes significantly form solc 7 to 8, one reason ist the abi default changed,
  but 8 also has an address table at the end that I don't understand.
