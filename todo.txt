DONE:
  CALLDATALOAD, CALLVALUE; CALLSIZE seams to be rare
  is swarm code removed from the skeletons? -> yes
  split framework and runs
FIRST:

  significant
    log
    Storage
    # Environmental Information
    # Block Information
    # System Operations
TODO:
  events? -> log

  write a hello word smart contract and compile it
    deployment code vs deployed code
    function signatures
    function ordering
      verify that function are ordered by signatures in runtime code (deployed code)
    how to function splitting

  ssdeep with spliced out 0s could perform pretty good, because functions are ordered

  how can is split the framework and the test-runs and document the runs?
  how will this be used?
  define a few test sets
  bzHash
LATER:
  invalid byte-codes at the end of skeleton?
  skeletize rstrip trailing zeros?
NOTES:
  select encode(addr, 'hex') from account where id = 485783246;
  bindata(cdeployed) as hex
  select only code with distinct skeletons from es verified contracts and group by name + signatures

  * Umwandlung von Header(s) in Signature(s)
    func2sig(text) ==> bytea
    func2sig(text[]) ==> bytea[]
    Beispiel: select func2sig('transfer(address,uint256)'); -- \xa9059cbb
  * Umwandlung von Header(s) in Id(s)
    func2sig(text) ==> integer
    func2sig(text[]) ==> integer[]
    Beispiel: select func2id('transfer(address,uint256)'); -- -1459249989
  * Umwandlung von Signature(s) in Header(s)
    func2sig(bytea) ==> text
    func2sig(bytea[]) ==> text[]
  * Umwandlung von Id(s) in Header(s)
    func2sig(integer) ==> text
    func2sig(integer[]) ==> text[]
  * Anzeige von Signaturen als Signatur+Header
    display_funsig(bytea) ==> text
    display_funsig(id) ==> text
    display_funsig(bytea[]) ==> text
    display_funsig(id[]) ==> text
    Beispiel: select display_funcsig(-1459249989); -- 'a9059cbb transfer(address,uint256)'
  * Umwandlung zwischen Signature(s) und Integer-Id(s)
    sig2id(bytea) ==> integer
    sig2id(bytea[]) ==> integer[]
    id2sig(integer) ==> bytea
    id2sig(integer[]) ==> bytea[]
THOUGHTS:
  lzjd correlations much better to signature-similarity than ssdeep and its really fast
  ssdeep can't event beat counting bytes of the skeleton

  ssdeep with jaccard underperforms levenshtein because of the high number of 'K' chunk hashes.

  signatures in the jump table at the beginning of the contract are sorted
    and the functions jumped to are sorted as well
